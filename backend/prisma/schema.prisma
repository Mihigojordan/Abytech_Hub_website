// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Admin {
  id                   String      @id @unique @default(uuid())
  adminName            String?
  adminEmail           String?     @unique
  phone                String?
  location             String?
  identityCardPublicId String?
  passportPublicId     String?
  cvPublicId           String?
  profileImagePublicId String?
  password             String?
  profileImage         String?
  status               AdminStatus @default(ACTIVE)
  google_id            String?     @unique
  is2FA                Boolean?    @default(false)
  idNumber             Int?
  bio                  String?     @db.Text
  experience           Json? // array of {from,to,companyName,jobTitle,JobDescription}
  joinedDate           DateTime?
  isLocked             Boolean?    @default(false)
  skills               Json? // array
  portifilio           Json? // array

  // files
  cv           String?
  passport     String?
  identityCard String?

  // Chat online status tracking
  isOnline     Boolean?  @default(false)
  lastSeen     DateTime? @map("last_seen") @db.Timestamp(0)

  // Push notification subscription
  subscription Json? // stores the push subscription object (endpoint + keys)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Original relations
  replies  ReplyReport[]
  expenses Expense[]
  report   Report[]

  research Research[]
  meetings Meeting[]
  internshipApplications InternshipApplication[]
  weeklyGoals WeeklyGoal[]
  demoRequests DemoRequest[]

  @@map("Admin")
}


model Notification {
  id          String   @id @default(cuid())
  recipients  Json     // [{id: string, type: "ADMIN" | "STAFF", read: false, link: string | null}]
  senderId    String?
  senderType  SenderType?
  title       String
  message     String
  createdAt   DateTime @default(now())

  @@map("Notification")
}

enum SenderType {
  ADMIN
  STAFF
}

model PushSubscription {
  id              String   @id @default(cuid())
  userId          String
  type            UserType
  endpoint        String   @db.LongText
  p256dh          String?  @db.LongText
  auth            String?  @db.LongText
  contentEncoding String   @default("aes128gcm")
  createdAt       DateTime @default(now())
  label           String?

  @@index([userId, type])
  @@map("PushSubscription")
}

enum UserType {
  ADMIN
  STAFF
}



model User {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(255)
  email     String    @unique @db.VarChar(255)
  password  String    @db.VarChar(255)
  avatar    String?   @db.VarChar(500)
  initial   String?   @db.VarChar(5)
  lastSeen  DateTime? @map("last_seen") @db.Timestamp(0)
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamp(0)

  isOnline     Boolean?  @default(false)



  @@map("users")
}

enum AdminStatus {
  ACTIVE
  INACTIVE
}


model Research {
  id              String   @id @default(cuid())
  title           String
  slug            String   @unique
  description     String?

  // Research content sections
  problem         Json? // problem statement
  objective       Json? // research objectives
  methodology     Json? // methods used
  findings        Json? // results / findings
  conclusion      Json?
  recommendations Json?

  // Classification
  type            ResearchType
  status          ResearchStatus @default(DRAFT)

  startDate       DateTime?
  endDate         DateTime?

  // Ownership
  ownerId         String
  owner           Admin    @relation(fields: [ownerId], references: [id])

  // Versioning / summary
  summary         String? // short plain-text summary

  // Supporting files [{ filename, url, size }]
  attachments     Json?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}
enum ResearchStatus {
  DRAFT
  IN_PROGRESS
  COMPLETED
  REVIEW
  PUBLISHED
}

enum ResearchType {
  TECHNICAL
  MARKET
  USER
  PERFORMANCE
  OTHER
}



model Meeting {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.LongText

  startTime   DateTime
  endTime     DateTime?

  status      MeetingStatus @default(SCHEDULED)

  location    String?
  meetingLink String?

  // JSON sections
  participants Json? 
  // [
  //   { "adminId": "id", email:'john@gmail.com' ,"name": "John", "attended": true }
  // ]

  keyPoints   Json?
  // [
  //   { "title": "Database Issue", "notes": "...", }
  // ]

  actionItems Json?
  // [
  //   { "task": "Fix API", "assignedToId": "id", name:"john", "dueDate": "...", "completed": false }
  // ]

  attachments Json?
  // [
  //   { "fileName": "slides.pdf", "fileUrl": "...", "fileType": "pdf" }
  // ]

  createdById String
  createdBy   Admin @relation(fields: [createdById], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum MeetingStatus {
  SCHEDULED
  ONGOING
  COMPLETED
  CANCELLED
}

model InternshipApplication {
  id             String   @id @default(cuid())

  // Applicant info
  fullName       String
  email          String
  phone          String?
  institution    String?
  fieldOfStudy   String?
  level          String?

  // Location / address (useful for filtering locals)
  country        String?
  city           String?

  // Internship details
  internshipType InternshipType
  period         InternshipPeriod?
  preferredStart DateTime?
  preferredEnd   DateTime?

  // Motivation & skills
  coverLetter    String?   @db.Text
  skills         Json?     // ["JavaScript", "Figma", "NestJS"]

  // Links & documents
  cvUrl          String?
  portfolioUrl   String?
  githubUrl      String?
  linkedinUrl    String?

  // Internal scoring (very useful during review)
  score          Int?      // e.g. reviewer gives 1–10

  // Status
  status         InternshipStatus @default(PENDING)

  // Internal review
  reviewedById   String?
  reviewedBy     Admin?    @relation(fields: [reviewedById], references: [id])
  reviewNotes    String?   @db.Text
  reviewedAt     DateTime?

  // Flags
  isShortlisted  Boolean   @default(false)
  isContacted    Boolean   @default(false)

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}


enum InternshipStatus {
  PENDING
  REVIEWING
  ACCEPTED
  REJECTED
  WAITLISTED
}

enum InternshipType {
  SOFTWARE_DEVELOPMENT
  UI_UX
  DATA
  MARKETING
  IT_SUPPORT
  OTHER
}

enum InternshipPeriod {
  ONE_MONTH
  THREE_MONTHS
  SIX_MONTHS
  ONE_YEAR
}

model HostedWebsite {
  id          String   @id @default(cuid())
  name        String
  domain      String   @unique
  description String?

  status      WebsiteStatus @default(ACTIVE)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


enum WebsiteStatus {
  ACTIVE
  SUSPENDED
  EXPIRED
}


model WeeklyGoal {
  id          String   @id @default(cuid())

  title       String
  description String?

  // Week identification
  weekStart   DateTime
  weekEnd     DateTime

  // Progress
  status      WeeklyGoalStatus @default(PENDING)
  progress    Int @default(0) // 0–100%

  // Ownership
  ownerId     String
  owner       Admin @relation(fields: [ownerId], references: [id])

  // Weekly tasks
  tasks       Json? // [{ title, description, done }]

  // End-of-week reflection
  reviewNotes String?  @db.LongText  [{adminId:"id",name:'serge',notes:"...."}]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
enum WeeklyGoalStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  MISSED
}

model DemoRequest {
  id            String   @id @default(cuid())

  // User requesting the demo
  fullName      String
  email         String
  phone         String?

  companyName   String?
  message       String? // what they want to see in the demo

  // What demo they want
  product       String? // e.g. "Inventory System", "Booking Platform"
  demoType      DemoType

  // Preferred schedule
  preferredDate DateTime?
  preferredTime String? // e.g. "Morning", "14:00–16:00"

  // Request lifecycle
  status        DemoRequestStatus @default(PENDING)

  // Internal handling
  assignedToId  String?
  assignedTo    Admin?  @relation(fields: [assignedToId], references: [id])

  scheduledAt   DateTime? // actual demo date
  meetingLink   String?

  internalNotes String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

enum DemoRequestStatus {
  PENDING
  CONTACTED
  SCHEDULED
  COMPLETED
  CANCELLED
}

enum DemoType {
  PRODUCT
  FEATURE
  CUSTOM
}



// ============================================
// CHAT MODELS
// ============================================

model Conversation {
  id        Int   @id @default(autoincrement())
  name      String?  @db.VarChar(255)
  avatar    String?  @db.VarChar(500)
  initial   String?  @db.VarChar(5)
  isGroup   Boolean  @default(false) @map("is_group")
  
  // Polymorphic creator - can be Admin or User (NO FK constraint)
  createdBy     String           @map("created_by")
  createdByType ParticipantType  @map("created_by_type")
  
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamp(0)

  // Relations - NO foreign key constraints for polymorphic fields
  participants ConversationParticipant[]
  messages     Message[]

  @@index([createdBy])
  @@index([isGroup])
  @@index([createdByType])
  @@map("conversations")
}

model ConversationParticipant {
  id             Int          @id @default(autoincrement())
  conversationId Int          @map("conversation_id")
  
  // Polymorphic participant - can be Admin or User (NO FK constraint)
  participantId   String          @map("participant_id")
  participantType ParticipantType @map("participant_type")
  
  role              Role      @default(member)
  joinedAt          DateTime  @default(now()) @map("joined_at") @db.Timestamp(0)
  leftAt            DateTime? @map("left_at") @db.Timestamp(0)
  lastReadMessageId Int?   @map("last_read_message_id")

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  lastReadMessage Message?     @relation("LastReadMessage", fields: [lastReadMessageId], references: [id], onDelete: SetNull)

  @@unique([conversationId, participantId, participantType], name: "unique_conversation_participant")
  @@index([conversationId])
  @@index([participantId])
  @@index([participantType])
  @@index([lastReadMessageId])
  @@map("conversation_participants")
}

model Message {
  id               Int      @id @default(autoincrement())
  conversationId   Int      @map("conversation_id")
  
  // Polymorphic sender - can be Admin or User (NO FK constraint)
  senderId         String          @map("sender_id")
  senderType       ParticipantType @map("sender_type")
  
  type             MessageType @default(text)
  content          String?     @db.Text
  replyToMessageId Int?     @map("reply_to_message_id")
  edited           Boolean     @default(false)
  isForwarded      Boolean     @default(false) @map("is_forwarded")
  timestamp        DateTime    @default(now()) @db.Timestamp(0)
  createdAt        DateTime    @default(now()) @map("created_at") @db.Timestamp(0)
  updatedAt        DateTime    @default(now()) @updatedAt @map("updated_at") @db.Timestamp(0)

  // Relations
  conversation           Conversation              @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  replyToMessage         Message?                  @relation("MessageReplies", fields: [replyToMessageId], references: [id], onDelete: SetNull)
  replies                Message[]                 @relation("MessageReplies")
  images                 MessageImage[]
  files                  MessageFile[]
  readers                MessageReader[]
  lastReadByParticipants ConversationParticipant[] @relation("LastReadMessage")

  @@index([conversationId])
  @@index([senderId])
  @@index([senderType])
  @@index([timestamp])
  @@index([replyToMessageId])
  @@fulltext([content])
  @@map("messages")
}

model MessageImage {
  id         Int   @id @default(autoincrement())
  messageId  Int   @map("message_id")
  imageUrl   String   @map("image_url") @db.VarChar(500)
  imageOrder Int      @default(0) @map("image_order")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamp(0)

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@map("message_images")
}

model MessageFile {
  id        Int   @id @default(autoincrement())
  messageId Int   @map("message_id")
  fileName  String   @map("file_name") @db.VarChar(255)
  fileSize  String?  @map("file_size") @db.VarChar(50)
  fileUrl   String   @map("file_url") @db.VarChar(500)
  fileType  String?  @map("file_type") @db.VarChar(100)
  fileOrder Int      @default(0) @map("file_order")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(0)

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@map("message_files")
}

model MessageReader {
  id         Int          @id @default(autoincrement())
  messageId  Int          @map("message_id")
  
  // Polymorphic reader - can be Admin or User (NO FK constraint)
  readerId   String          @map("reader_id")
  readerType ParticipantType @map("reader_type")
  
  readAt DateTime @default(now()) @map("read_at") @db.Timestamp(0)

  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([messageId, readerId, readerType], name: "unique_message_reader")
  @@index([messageId])
  @@index([readerId])
  @@index([readerType])
  @@map("message_readers")
}

model Contact {
  id            Int          @id @default(autoincrement())
  
  // Polymorphic owner - can be Admin or User (NO FK constraint)
  ownerId       String          @map("owner_id")
  ownerType     ParticipantType @map("owner_type")
  
  // Polymorphic contact - can be Admin or User (NO FK constraint)
  contactId     String          @map("contact_id")
  contactType   ParticipantType @map("contact_type")
  
  nickname  String?  @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(0)

  // Relations - NO foreign key constraints for polymorphic fields

  @@unique([ownerId, contactId, ownerType, contactType], name: "unique_owner_contact")
  @@index([ownerId])
  @@index([contactId])
  @@index([ownerType])
  @@index([contactType])
  @@map("contacts")
}

// ============================================
// ENUMS
// ============================================

enum Role {
  admin
  member
}

enum MessageType {
  text
  image
  file
  combined
}

enum ParticipantType {
  ADMIN
  USER
}


model Expense {
  id          String   @id @default(uuid())
  title       String
  amount      Float
  status      ExpenseStatus @default(PENDING)
  description String?
  reason String?
  adminId     String
  createdAt   DateTime @default(now())
  admin    Admin    @relation(fields: [adminId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    @@map("Expense")
}

enum ExpenseStatus{
    PENDING
    APPROVED
    REJECTED
    COMPLETED
}


model Report{
  id         String   @id @default(uuid())
  title       String
  content     Json?
  reportUrl   String?
  publicId    String?
  createdAt   DateTime 
  adminId    String
  admin   Admin    @relation(fields: [adminId], references: [id], onDelete: Cascade, onUpdate: Cascade)
   replies    ReplyReport[] 
     @@map("Report")
}

model ReplyReport {
  id           String   @id @default(uuid())
  content      String

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Foreign keys
  reportId     String
  report       Report   @relation(fields: [reportId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  adminId      String
  admin        Admin    @relation(fields: [adminId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    @@map("ReplyReport")
}





